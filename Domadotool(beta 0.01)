<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title> 영상처리 소프트웨어 (Beta 6) </title>
    <link rel="stylesheet" href="my.css" type="text/css">
    <style>
          
          #aaa{ background-image:url(C:HTML5/Domadorai.jpg); 
          background-repeat: repeat;}

  
        
        .asied{ 

            margin:0;
        }
        
        .wrap{
          width: 60vw;
      
        }
        body {
          
          background-size: auto;
          text-align: center;
          justify-content: center;
         
          height: 100vh;
      }
    

      
        .canvas {
            padding: 10px;
            margin: 15px;
            margin-right: Auto;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.6);
            height : auto;
        }
        .canvas2 {
            border-radius: 7px;
            border: 4px solid black;
            padding: 10px;
            margin: 15px;
            margin-right: Auto;
            text-align: center;
            background-color: rgba(255, 255, 255, 0.6);
        }
        
     
        
        .toolMenu {
            background: rgb(255, 255, 255);
            /* fallback for old browsers */
            background: -webkit-linear-gradient rgba(69, 160, 168);
            /* Chrome 10-25, Safari 5.1-6 */
            background: linear-gradient  rgb(255, 255, 255);
            /* W3C, IE 10+/ Edge, Firefox 16+, Chrome 26+, Opera 12+, Safari 7+ */

          
            margin-top: 20px;
            margin-bottom: 900px;
            margin-left: Auto;
            text-align: center;
            width: 400px;
            border: 4px solid black;
            border-radius: 10px;
            line-height: 30px;
            padding: 5px;
            height: 80%;

        }

        
       
        .bar1 {
            border-radius: 10px;
            border: 4px solid black;
            margin: 0;
            text-align: center;
            margin-top: 20px;
            margin-bottom: 20px;
            margin-right: 20px;
            background-color: rgba(69, 160, 168);
            
        }

        .bar2 {
            display: flex; /*이놈이 문제인것 같음*/
            margin: 0;
            text-align: center;
            color: black;
            border: 4px solid black;
            border-radius: 10px;
            background-color: rgb(255, 255, 255, 0.4);
            
            height: 80vh;
            
        }
    /* //    69, 160, 168 0.6 */

    .bar3 {
            border-radius: 10px;
            border: 4px solid black;
            margin: 0;
            margin-top: 20px;
            margin-bottom: 20px;
            margin-right: 20px;
            background-color: rgba(69, 160, 168);
            height: 10%;
            
        }
        .bar4 {
            border-radius: 10px;
            border: 4px solid black;
            margin: 0;
                 
            text-align: center;
            margin-top: 20px;
            margin-bottom: 20px;
            margin-left:20px; 
            margin-right: 20px;
            background-color: rgba(69, 160, 168);
            
        }

        .bar5{
            margin: 0;

        }
        /* .domado {
            display: flex;
            height: 150px;
            background: #a2d5f2
            } */

      </style>

    <script>
        // 전역 변수(*중요*)
        var inCanvas, inCtx, outCanvas, outCtx;  // 입력 캔버스 관련
        var inFile, inImageArray, outImageArray;  // 입력 파일 및 배열
        var inWidth, inHeight, outWidth, outHeight;  // 입력 영상의 폭과 높이
        var inPaper,outPaper; // 캔버스에는 한점한점이 안찍힘. 대신 캔버스에 종이를 붙임.
        //히스토그래픽관련 변수
        var histoArray;
        var inCanvas2, inCtx2, outCanvas2, outCtx2;
        var inPaper2, outPaper2;
        var inHistoArray, outHistoArray;
       

        // *** 공통 함수 모음 ***




        function init() {
            inCanvas = document.getElementById('inCanvas');
            inCtx = inCanvas.getContext('2d');
            outCanvas = document.getElementById('outCanvas');
            outCtx = outCanvas.getContext('2d');
            inCanvas2 = document.getElementById('inCanvas2');
            inCtx2 = inCanvas2.getContext('2d');
            outCanvas2 = document.getElementById('outCanvas2');
            outCtx2 = outCanvas2.getContext('2d');
        }
        
        function openImage() {
            inFile = document.getElementById('selectFile').files[0];
            // 중요! 코드 (영상의 크기를 파악)
            inWidth = inHeight = Math.sqrt(inFile.size);
            // 입력 2차원 배열을 준비
            inImageArray = new Array(inHeight); // 512짜리 1차원 배열
            for(var i=0; i<inHeight; i++) 
                inImageArray[i] = new Array(inWidth);
            // RAW 파일  --> 2차원 배열
            inCanvas.width = inWidth;
            inCanvas.height = inHeight;
            
            var reader = new FileReader();
            reader.readAsBinaryString(inFile);
            reader.onload = function () {
                var bin = reader.result; // 파일을 덩어리(bin)로 읽었음
                // 덩어리(bin)에서 한점한점씩 뽑아서, 배열에 넣기
                for(var i=0; i<inHeight; i++) {
                    for(var k=0; k<inWidth; k++) {
                        var sPixel = (i * inHeight + k);
                        var ePixel = (i * inHeight + k) + 1;
                        inImageArray[i][k] = bin.slice(sPixel,ePixel); // 1개픽셀-->배열
                    }
                }
                inPaper = inCtx.createImageData(inHeight, inWidth); //종이 붙였음.
                for(var i=0; i<inHeight; i++) {
                    for (var k=0; k<inWidth; k++) {
                        var charValue = inImageArray[i][k].charCodeAt(0); // 깨진문자를 숫자로.
                        inPaper.data[(i*inWidth + k) * 4 + 0] = charValue; // R
                        inPaper.data[(i*inWidth + k) * 4 + 1] = charValue; // G
                        inPaper.data[(i*inWidth + k) * 4 + 2] = charValue; // B
                        inPaper.data[(i*inWidth + k) * 4 + 3] = 255; // Alpha
                    }
                }
                inCtx.putImageData(inPaper,0,0); // 출력 2차원 배열을 준비
                inHistoArray = new Array(20);
                for (var i = 0; i < 20; i++)
                    inHistoArray[i] = new Array(256);

                histoMake(inImageArray);
                printInImage2();
            }

            }
                
                equalImage();


                async function SaveImage(el){
                   var name = document.getElementById('downlink');
                   name.download = prompt("이름을 입력하세요.","SaveImage");
                    const imageURI = outCanvas.toDataURL("image/jpg");
                    el.href = imageURI;
                }
      
        function printOutImage() {
            outCanvas.width = outWidth;
            outCanvas.height = outHeight;
            outPaper = outCtx.createImageData(outHeight, outWidth); //종이 붙였음.
            for (var i = 0; i < outHeight; i++) {
                for (var k = 0; k < outWidth; k++) {
                    var charValue = outImageArray[i][k].charCodeAt(0); // 깨진문자를 숫자로.
                    outPaper.data[(i * outWidth + k) * 4 + 0] = charValue; // R
                    outPaper.data[(i * outWidth + k) * 4 + 1] = charValue; // G
                    outPaper.data[(i * outWidth + k) * 4 + 2] = charValue; // B
                    outPaper.data[(i * outWidth + k) * 4 + 3] = 255; // Alpha
                }
            }
            outCtx.putImageData(outPaper, 0, 0);
        }

        function printInImage2() {
            // 캔버스 크기를 결정
            inCanvas2.width = 256;
            inCanvas2.height = 256;
            inPaper2 = inCtx2.createImageData(256, 256); //종이 붙였음.
            for (var i = 0; i < 256; i++) {
                for (var k = 0; k < 256; k++) {
                    var charValue = histoArray[i][k].charCodeAt(0); // 깨진문자를 숫자로.
                    inPaper2.data[(i * 256 + k) * 4 + 0] = charValue; // R
                    inPaper2.data[(i * 256 + k) * 4 + 1] = charValue; // G
                    inPaper2.data[(i * 256 + k) * 4 + 2] = charValue; // B
                    inPaper2.data[(i * 256 + k) * 4 + 3] = 255; // Alpha
                }
            }
            inCtx2.putImageData(inPaper2, 0, 0);
            printHisto1();
        }

        function printOutImage2() {
            // 캔버스 크기를 결정
            outCanvas2.width = 256;
            outCanvas2.height = 256;
            outPaper2 = outCtx2.createImageData(256, 256); //종이 붙였음.
            for (var i = 0; i < 256; i++) {
                for (var k = 0; k < 256; k++) {
                    var charValue = histoArray[i][k].charCodeAt(0); // 깨진문자를 숫자로.
                    outPaper2.data[(i * 256 + k) * 4 + 0] = charValue; // R
                    outPaper2.data[(i * 256 + k) * 4 + 1] = charValue; // G
                    outPaper2.data[(i * 256 + k) * 4 + 2] = charValue; // B
                    outPaper2.data[(i * 256 + k) * 4 + 3] = 255; // Alpha
                }
            }
            outCtx2.putImageData(outPaper2, 0, 0);
            printHisto2();
        }


        function displayImage() {
              // 캔버스 크기를 결정
            outCanvas.width = outWidth;
            outCanvas.height = outHeight;
            outPaper = outCtx.createImageData(outHeight, outWidth); //종이 붙였음.
            for(var i=0; i<outHeight; i++) {
                for (var k=0; k<outWidth; k++) {
                    var charValue = outImageArray[i][k].charCodeAt(0); // 깨진문자를 숫자로.
                    outPaper.data[(i*outWidth + k) * 4 + 0] = charValue; // R
                    outPaper.data[(i*outWidth + k) * 4 + 1] = charValue; // G
                    outPaper.data[(i*outWidth + k) * 4 + 2] = charValue; // B
                    outPaper.data[(i*outWidth + k) * 4 + 3] = 255; // Alpha
                }
            }
            outCtx.putImageData(outPaper,0,0);
        }

        function histoMake(array1) {
            // 히스토그램 생성
            var histo = new Array(256);
            for (var i = 0; i < 256; i++)
                histo[i] = 0;
            for (var i = 0; i < 256; i++) {
                for (var k = 0; k < 256; k++) {
                    // 문자 --> 숫자
                    value = array1[i][k].charCodeAt(0);
                    // **** 요기가 핵심 알고리즘.
                    histo[value]++;
                }
            }
            // 히스토그램 정규화
            var max = 0;
            var min = 256 * 256;
            for (var i = 0; i < 256; i++) {
                if (histo[i] < min)
                    min = histo[i];
                if (histo[i] > max)
                    max = histo[i];
            }
            var dif = max - min
            var normalHisto = new Array(256);
            for (var i = 0; i < 256; i++)
                normalHisto[i] = (histo[i] - min) * 255 / dif;
            // 출력 2차원 배열을 준비
            histoArray = new Array(256);
            for (var i = 0; i < 256; i++)
                histoArray[i] = new Array(256);
            // 배열 초기화
            for (var i = 0; i < 256; i++) {
                for (var k = 0; k < 256; k++) {
                    histoArray[i][k] = 255;
                }
            }
            // 히스토그램 출력 배역 생성
            for (var i = 0; i < 256; i++) {
                for (var k = 0; k < normalHisto[i]; k++) {
                    histoArray[255 - k][i] = 0;
                }
            }
            for (var i = 0; i < 256; i++) {
                for (var k = 0; k < 256; k++) {
                    // 숫자 --> 문자
                    histoArray[i][k] = String.fromCharCode(histoArray[i][k]);
                }
            }
        }
        function printHisto1() {
            // 캔버스 크기를 결정
            inCanvas3.width = 256;
            inCanvas3.height = 20;
            inPaper3 = inCtx3.createImageData(256, 20); //종이 붙였음.
            for (var i = 0; i < 20; i++) {
                for (var k = 0; k < 256; k++) {
                    inHistoArray[i][k] = k;
                    var charValue = inHistoArray[i][k];//.charCodeAt(0); // 깨진문자를 숫자로.
                    inPaper3.data[(i * 256 + k) * 4 + 0] = charValue; // R
                    inPaper3.data[(i * 256 + k) * 4 + 1] = charValue; // G
                    inPaper3.data[(i * 256 + k) * 4 + 2] = charValue; // B
                    inPaper3.data[(i * 256 + k) * 4 + 3] = 255; // Alpha
                }
            }
            inCtx3.putImageData(inPaper3, 0, 0);
        }

        function printHisto2() {
            // 캔버스 크기를 결정
            outCanvas3.width = 256;
            outCanvas3.height = 20;
            outPaper3 = outCtx3.createImageData(256, 20); //종이 붙였음.
            for (var i = 0; i < 20; i++) {
                for (var k = 0; k < 256; k++) {
                    inHistoArray[i][k] = k;
                    var charValue = inHistoArray[i][k];//.charCodeAt(0); // 깨진문자를 숫자로.
                    outPaper3.data[(i * 256 + k) * 4 + 0] = charValue; // R
                    outPaper3.data[(i * 256 + k) * 4 + 1] = charValue; // G
                    outPaper3.data[(i * 256 + k) * 4 + 2] = charValue; // B
                    outPaper3.data[(i * 256 + k) * 4 + 3] = 255; // Alpha
                }
            }
            outCtx3.putImageData(outPaper3, 0, 0);
        }

        

        function ImageProcessing(selectNum) { // 선택번호를 받음.
            switch (selectNum.value) {
                case "1"  : equalImage();                         break;
                case "2"  : addImage();                           break;
                case "3"  : darkImage();                          break;
                case "4"  : bwImage();                            break;
                case "5"  :  bwAvg();                             break;
                case "21" :  zoomInImage() ;                      break;
                case "22" :  zoomOutImage ();                     break;
                // case "23" :  rotate1Image ();                     break;
                case "24" :  rotate2Image ();                     break;
                case "25" :  onmirrorHorImage ();                 break;
                case "26" :  onmirrorVerImage ();                break;
                case "41" :   histogram();                        break;
                case "42" :   endinFind ();                       break;
                case "43" :   histoequal();                       break;
                case "61" : embossImage();                       break;
                case "62" : blurrImage();                        break;
                case "63" : GaussianImage();                     break;
                case "64" : sharpImage();                        break;
                case "65" : onHpfSharp();                        break;
                case "66" : onLpfSharp();                        break;
                case "71" : loGImage();                          break;
                case "72" : doGImage();                          break;
            }
        }
        
        // *** 영상처리 함수 모음 ***
        function equalImage() {  // 동일 영상 알고리즘
                    // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                    outHeight = inHeight;
                    outWidth = inWidth;
                    // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);
                    // ***** 진짜 영상처리 알고리즘 *****
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                        
                            pixel = inImageArray[i][k].charCodeAt(0);
                            outImageArray[i][k] = inImageArray[i][k];
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                }

                function addImage() {//영상밝게하기 함수
                    
                    // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                    outHeight = inHeight;
                    outWidth = inWidth;
                        // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);

                    // ***** 진짜 영상처리 알고리즘 *****
                    var value = parseInt(prompt("밝게할 값", "0"));
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // 문자 --> 숫자
                            pixel = inImageArray[i][k].charCodeAt(0);
                            // **** 요기가 핵심 알고리즘. (밝게하기)
                            if (pixel + value > 255)
                                pixel = 255;
                            else 
                                pixel += value;
                            // 숫자 --> 문자
                            outImageArray[i][k] = String.fromCharCode(pixel);
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
                    
                    }
                    function darkImage() {//영상밝게하기 함수
                    
                    // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                    outHeight = inHeight;
                    outWidth = inWidth;
                        // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);

                    // ***** 진짜 영상처리 알고리즘 *****
                    var value = parseInt(prompt("어둡게할 값", "0"));
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // 문자 --> 숫자
                            pixel = inImageArray[i][k].charCodeAt(0);
                            // **** 요기가 핵심 알고리즘. (밝게하기)
                            if (pixel + value > 255)
                                pixel = 255;
                            else 
                                pixel -= value;
                            // 숫자 --> 문자
                            outImageArray[i][k] = String.fromCharCode(pixel);
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
                    
                    }


                
//흑백처리 구동안되는 현상 발생
            function bwImage() {
                        outHeight = inHeight;
                        outWidth = inWidth;
                        // 출력 2차원 배열을 준비
                        outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                        for(var i=0; i<outHeight; i++) 
                            outImageArray[i] = new Array(outWidth);

                        // ***** 진짜 영상처리 알고리즘 *****
                        var value = parseInt(prompt("기준 값", "127"));
                        for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // 문자 --> 숫자
                            pixel = inImageArray[i][k].charCodeAt(0);
                            // **** 요기가 핵심 알고리즘. (흑백)
                            if (pixel > value)
                                pixel = 255;
                            else   
                                pixel = 0;
                            // 숫자 --> 문자
                            outImageArray[i][k] = String.fromCharCode(pixel);
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
                }
                 
                function zoomInImage() {

                       // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                       var scale = parseInt(prompt("축소 배율(짝수)", "2"));
                    outHeight = parseInt(inHeight/scale);
                    outWidth = parseInt(inWidth/scale);
                    // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);

                    // ***** 진짜 영상처리 알고리즘 *****
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // **** 요기가 핵심 알고리즘. (영상 축소)
                            outImageArray[parseInt(i/scale)][parseInt(k/scale)] = inImageArray[i][k];
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();                
            }

                function zoomOutImage (){
                    // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                    var scale = parseInt(prompt("확대 배율(짝수)", "2"));
                    outHeight = inHeight*scale;
                    outWidth = inWidth*scale;
                    // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);
                    // outImageArray를 초기화 시키기 (0으로 채우기)
                    for(var i=0; i<outHeight; i++) 
                        for (var k=0; k<outWidth; k++) 
                            outImageArray[i][k] = String.fromCharCode(0);

                    // ***** 진짜 영상처리 알고리즘 *****
                    for(var i=0; i<outHeight; i++) {
                        for (var k=0; k<outWidth; k++) {
                            // **** 요기가 핵심 알고리즘. (영상 축소)
                            outImageArray[i][k] = inImageArray[parseInt(i/scale)][parseInt(k/scale)];
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();                    
                }

                function histogram() {

                        // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                        outHeight = inHeight;
                    outWidth = inWidth;
                    // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);

                    // ***** 진짜 영상처리 알고리즘 *****
                    //  out =  ( in - low ) / ( high - low ) * 255
                    var low = inImageArray[0][0].charCodeAt(0);
                    var high = inImageArray[0][0].charCodeAt(0);
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            pixel = inImageArray[i][k].charCodeAt(0);
                            if (pixel < low) 
                                low = pixel;
                            if (pixel > high)
                                high = pixel
                        }
                    }
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // 문자 --> 숫자
                            inVal = inImageArray[i][k].charCodeAt(0);
                            // **** 요기가 핵심 알고리즘. (흑백)
                            outVal = ( inVal - low ) / ( high - low ) * 255;
                            // 숫자 --> 문자
                            outImageArray[i][k] = String.fromCharCode(outVal);
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                }

                function endinFind () {
                    // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                    outHeight = inHeight;
                    outWidth = inWidth;
                    // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);

                    // ***** 진짜 영상처리 알고리즘 *****
                    //  out =  ( in - low ) / ( high - low ) * 255
                    var low = inImageArray[0][0].charCodeAt(0);
                    var high = inImageArray[0][0].charCodeAt(0);
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            pixel = inImageArray[i][k].charCodeAt(0);
                            if (pixel < low) 
                                low = pixel;
                            if (pixel > high)
                                high = pixel
                        }
                    }

                    low += 50;
                    high -= 50;

                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // 문자 --> 숫자
                            inVal = inImageArray[i][k].charCodeAt(0);
                            // **** 요기가 핵심 알고리즘. (흑백)
                            outVal = ( inVal - low ) / ( high - low ) * 255;
                            if (outVal > 255)
                                outVal = 255;
                            else if (outVal < 0)
                                outVal = 0;

                            // 숫자 --> 문자
                            outImageArray[i][k] = String.fromCharCode(outVal);
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                                    }

                    function histoequal() {

                         // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                    outHeight = inHeight;
                    outWidth = inWidth;
                    // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);

                    // ***** 진짜 영상처리 알고리즘 *****
                    // 1단계 : 히스토그램 생성
                    histo = new Array(256);  
                    for (var i=0; i<256; i++)
                        histo[i] = 0;
                    for(var i=0; i<inHeight; i++) 
                        for (var k=0; k<inWidth; k++) {
                            value = inImageArray[i][k].charCodeAt(0);
                            histo[value] ++;
                        }
                    // 2단계 : 누적 히스토그램 생성
                    sumHisto = new Array(256);  
                    for (var i=0; i<256; i++)
                        sumHisto[i] = 0;     
                    sumVal = 0;                       
                    for (var i=0; i<256; i++) {
                        sumVal += histo[i];
                        sumHisto[i] = sumVal;
                    }
                    // 3단계 : 정규화된 누적히스토그램
                    // ns = s * (1/픽셀총수) * 화소최대밝기
                    normalHisto = new Array(256);  
                    for (var i=0; i<256; i++)
                        normalHisto[i] = 0.0; 
                    for (var i=0; i<256; i++)
                        normalHisto[i] = sumHisto[i] * ( 1 / (inWidth*inHeight)) * 255;
                        
                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // 문자 --> 숫자
                            inVal = inImageArray[i][k].charCodeAt(0);
                            // **** 요기가 핵심 알고리즘. (흑백)
                            outVal = normalHisto[inVal];
                            if (outVal > 255)
                                outVal = 255;
                            else if (outVal < 0)
                                outVal = 0;
                            else 
                                outVal = parseInt(outVal);
                            // 숫자 --> 문자
                            outImageArray[i][k] = String.fromCharCode(outVal);
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                    }

                    function bwAvg() {

                    // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
                    outHeight = inHeight;
                    outWidth = inWidth;
                    // 출력 2차원 배열을 준비
                    outImageArray = new Array(outHeight); // 256짜리 1차원 배열
                    for(var i=0; i<outHeight; i++) 
                        outImageArray[i] = new Array(outWidth);

                    // ***** 진짜 영상처리 알고리즘 *****
                    var hap = 0;
                    for(var i=0; i<inHeight; i++) 
                        for (var k=0; k<inWidth; k++) 
                            hap += inImageArray[i][k].charCodeAt(0);
                    var value = hap / (inHeight*inWidth) ;

                    for(var i=0; i<inHeight; i++) {
                        for (var k=0; k<inWidth; k++) {
                            // 문자 --> 숫자
                            pixel = inImageArray[i][k].charCodeAt(0);
                            // **** 요기가 핵심 알고리즘. (흑백)
                            if (pixel > value)
                                pixel = 255;
                            else   
                                pixel = 0;
                            // 숫자 --> 문자
                            outImageArray[i][k] = String.fromCharCode(pixel);
                        }
                    }
                    printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
                    }
   
        //             function rotate1Image() {  // 동일 영상 알고리즘 rotate2Image ();
        //     // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
        //     outHeight = inHeight;
        //     outWidth = inWidth;
        //     // 출력 2차원 배열을 준비
        //     outImageArray = new Array(outHeight); // 256짜리 1차원 배열
        //     for(var i=0; i<outHeight; i++) 
        //         outImageArray[i] = new Array(outWidth);
        //     // outImageArray를 초기화 시키기 (0으로 채우기)
        //     for(var i=0; i<outHeight; i++) 
        //         for (var k=0; k<outWidth; k++) 
        //             outImageArray[i][k] = String.fromCharCode(0);

        //              // ***** 진짜 영상처리 알고리즘 *****
        //     var degree = parseFloat(prompt("회전각도", 45));
        //     var radian = degree * Math.PI / 180.0; // degree->radian
                
        //   //xd = cos * xs - sin * ys;
        //   //yd = sin * xs + cos * ys;
        //   var xd, yd, xs, ys; 

        //     for(var i=0; i<inHeight; i++) {
        //         for (var k=0; k<inWidth; k++) {
          
        //             xs = i;
        //             ys = k; // parseInt묶기 --> 실수를 정수로 만들어준거
        //             xd = parseInt(Math.cos(radian) * xs - Math.sin(radian) * ys);
        //             yd = parseInt(Math.sin(radian) * xs + Math.cos(radian) * ys);
                    
        //             // 회전 이후의 위치가 출력영상의 범위 안에 있니?
        //             if((0<=xd && xd < outHeight) && (0<=yd && yd< outWidth))
        //             outImageArray[xd][yd] = inImageArray[xs][ys];

                     
        //         }
        //     }
        //     displayImage();
        // }
        function rotate2Image() {  // 회전백워딩
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);

                     // 회전 각도 -> degree - radian 변환
            var degree = parseFloat(prompt("회전각도", 45));
            var radian = degree * Math.PI / 180.0; // degree->radian
            radian = -radian;

          //xd = cos * xs - sin * ys;
          //yd = sin * xs + cos * ys;
          var xd, yd, xs, ys; 
          var cx = parseInt(inHeight / 2) ;
          var cy = parseInt(inWidth /2) ;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
          
                    xs = i;
                    ys = k; // parseInt묶기 --> 실수를 정수로 만들어준거
                    xd = parseInt(Math.cos(radian) * (xs-cx) - Math.sin(radian) * (ys-cy) + cx);
                    yd = parseInt(Math.sin(radian) * (xs-cx) + Math.cos(radian) * (ys-cy) + cy);             
                    // 회전 이후의 위치가 출력영상의 범위 안에 있니?
                    if((0<=xd && xd < outHeight) && (0<=yd && yd< outWidth))
                    outImageArray[xs][ys] = inImageArray[xd][yd];
                    else 
                    outImageArray[xs][ys] = String.fromCharCode(255);

                    // cx = Hcos(90-radian) + Wcos(radian);
                    // cy = Hcos(radian) + Wcos(90-radian);

//9- 29페이지 필요하면 구현
                }
            }
            printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();     
        }

        function   onmirrorHorImage () {  // 동일 영상 알고리즘 rotate2Image ();
           // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
           outHeight = inHeight;
           outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);
                  
          //xd = cos * xs - sin * ys;
          //yd = sin * xs + cos * ys;
          var xd, yd, xs, ys; 
          var cx = inHeight;
          var cy = inWidth;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    outImageArray[i][cy -k -1] =
                    inImageArray[i][k];
//9- 29페이지 필요하면 구현
                }
            }
            displayImage();
        }

        function   onmirrorVerImage () {  // 동일 영상 알고리즘 rotate2Image ();
           // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
           outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);
            // outImageArray를 초기화 시키기 (0으로 채우기)
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    outImageArray[i][k] = String.fromCharCode(0);
                  
          //xd = cos * xs - sin * ys;
          //yd = sin * xs + cos * ys;
          var xd, yd, xs, ys; 
          var cx = parseInt(inHeight) ;
          var cy = parseInt(inWidth ) ;
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    outImageArray[cx-i-1][k] = inImageArray[i][k];
            
                //9- 29페이지 필요하면 구현
                }
            }
            printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
        }

        function embossImage() {  // 엠보싱 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1., 0., 0.], 
                            [  0., 0., 0.], 
                            [  0., 0., 1.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) 
                    tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
                printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
        }

        function blurrImage() {  // 블러링 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1/9., 1/9., 1/9.], 
                            [ 1/9., 1/9., 1/9.], 
                            [ 1/9., 1/9., 1/9.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
                printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
        }

        function GaussianImage() {  //가우시안 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1./16., 1./8., 1./16.], 
                            [ 1./8., 1./4., 1./8.], 
                            [ 1./16., 1./8., 1./16.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0.0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
                printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
        }
        
        function sharpImage() {  //샤프 알고리즘
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1., -1., -1.], 
                            [ -1., 9., -1.], 
                            [ -1., -1., -1.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0.0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
                printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
        }
           
        function onHpfSharp() {  // 고주파
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ -1.%9., -1.%9., -1.%9.], 
                            [ -1.%9.,  8.%9., -1.%9.], 
                            [ -1.%9., -1.%9., -1.%9.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0.0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
                printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
        }
           
        function onLpfSharp() {  // 저주파
            // (중요!) 출력 영상의 크기를 결정... 알고리즘에 따름.
            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 1./9., 1./9., 1./9.], 
                            [ 1./9., 1./9., 1./9.], 
                            [ 1./9., 1./9., 1./9.]    ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+2); // 2칸 큼
            for(var i=0; i<inHeight + 2; i++) 
                tempInputArray[i] = new Array(inWidth + 2);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+2; i++) 
                for (var k=0; k<inWidth+2; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<3; m++) {
                        for (var n=0; n<3; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0.0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
                printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
        }

        function loGImage() {  // 차분처리            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 0., 0., -1.,  0.,  0.], 
                            [ 0., -1., -2., -1., 0.], 
                            [ -1., -2., 16. ,-2., -1.],
                            [ 0., -1., -2., -1., 0.], 
                            [ 0., 0., -1.,  0.,  0.]
                        ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+4); // 2칸 큼
            for(var i=0; i<inHeight + 4; i++) 
                tempInputArray[i] = new Array(inWidth + 4);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+4; i++) 
                for (var k=0; k<inWidth+4; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<5; m++) {
                        for (var n=0; n<5; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0.0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
                printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
        }

        function doGImage() {  // 차분처리            outHeight = inHeight;
            outWidth = inWidth;
            // 출력 2차원 배열을 준비
            outImageArray = new Array(outHeight); // 256짜리 1차원 배열
            for(var i=0; i<outHeight; i++) 
                outImageArray[i] = new Array(outWidth);

            //// 화소 영역 처리
            var mask = [    [ 0.,  0., -1., -1., -1.,  0., 0.], 
                            [ 0., -2., -3., -3., -3., -2., 0.], 
                            [ -1., -3., 5. ,5. ,  5., -3.,-1.],
                            [ -1., -3., 5. ,16. , 5., -3.,-1.],
                            [ -1., -3., 5. ,5. ,  5., -3.,-1.],
                            [ 0.,  -2.,-3. ,-3., -3., -2., 0.],
                            [ 0.,  0., -1., -1., -1.,  0., 0.], 
        ]
            // 임시 입력 배열
            tempInputArray = new Array(inHeight+6); // 2칸 큼
            for(var i=0; i<inHeight + 6; i++) 
                tempInputArray[i] = new Array(inWidth + 6);
            // 임시 입력 배열 초기화
            for(var i=0; i<inHeight+6; i++) 
                for (var k=0; k<inWidth+6; k++)                     
                    tempInputArray[i][k] = String.fromCharCode(127);
            // 입력 배열 --> 임시 입력
            for(var i=0; i<inHeight; i++) 
                for (var k=0; k<inWidth; k++) {
                    tempInputArray[i+1][k+1]  = inImageArray[i][k];
                }
            // 임시 출력 배열
            tempOutputArray = new Array(outHeight); //
            for(var i=0; i<outHeight; i++) 
                tempOutputArray[i] = new Array(outWidth);

            // ***** 진짜 영상처리 알고리즘 *****
            for(var i=0; i<inHeight; i++) {
                for (var k=0; k<inWidth; k++) {
                    var S = 0.0;
                    for (var m=0; m<7; m++) {
                        for (var n=0; n<7; n++) {
                            S += mask[m][n] * tempInputArray[i+m][k+n].charCodeAt(0);
                        }
                    }
                    tempOutputArray[i][k] = S;
                }
            }
            // 만약, 마스크의 합계가 0이면, 결과를 127 더하자.
            // for(var i=0; i<outHeight; i++) 
            //     for (var k=0; k<outWidth; k++) 
            //         tempOutputArray[i][k] += 127.0;

            // 임시 출력 --> 진짜 출력 배열
            for(var i=0; i<outHeight; i++) 
                for (var k=0; k<outWidth; k++) {
                    var v = tempOutputArray[i][k];
                    if (v > 255.0)
                        v = 255.0;
                    if (v < 0.0)
                        v = 0.0;
                    outImageArray[i][k] = String.fromCharCode(v);
                }
                printOutImage();
                    histoMake(outImageArray);
                    printOutImage2();
                
        }

        function downloadCanvas(link, canvasId, filename) { 
            link.href = document.getElementById(canvasId).toDataURL(); link.download = filename; }

            
   </script>
</head>
<aside id= "aaa">
<body  onload='init()'>
 
    <div class="wrap"> 
        <header><div class="company-name"><h3>Domado Tool</h3></div></header>  
    <div class="bar1">
        <br>
        <div class="company-name"><h3> (Beta0.01)</h3></div>
        <br>
    </div>
    <form>
        <article>        
            <div class="bar2">
            <div class="canvas">     
                <canvas id='inCanvas' style='background-color:#e4c0c0'width="300" height="300"></canvas></td>
                <canvas id='outCanvas' style='background-color:rgb(164, 248, 192)'width="300" height="300"></canvas>
                <br>
                
                </div>
               
               
              <div class = "toolMenu">
                <div class = "bar4">
                    <label>  <h2>    영상 처리</h2> </label>
                </div>
                

                    <input type='file' id='selectFile' onchange='openImage()'/>
                    <button><a id = 'downlink' download = 'SaveImage' href="" onclick='SaveImage(this)'>저장하기</a></button>
                        <select name='imageAlgo' onchange="ImageProcessing(this.form.imageAlgo)">
                            <option value = 0> 선택 하세요 </option>
                            <optgroup label="화소 점 처리">
                                <option value = "1"> 동일 영상 처리</option>
                                <option value = "2"> 영상 밝게 하기</option>
                                <option value = "3"> 영상 어둡게 하기</option>
                                <option value = "4"> 흑백 처리</option>
                                <option value = "5"> 흑백 처리(평균)</option>
                            </optgroup>
                                <optgroup label="기하학 처리">
                                <option value = "21"> 축소 하기</option>
                                <option value = "22"> 확대 하기</option>
                                    <!-- <option value = "23"> 회전 기본</option> -->
                                <option value = "24"> 회전 (백워딩,중앙회전)</option>
                                <option value = "25"> 좌우대칭</option>
                                <option value = "26"> 상하대칭</option>
                            </optgroup>
                                <optgroup label="히스토그램">
                                <option value = "41"> 히스토그램 스트래칭</option>
                                <option value = "42"> 엔드-인 탐색</option>
                                <option value = "43"> 평활화 </option>
                            </optgroup>
                                <optgroup label ="화소영역 처리">
                                <option value = "61"> 엠보싱 </option>
                                <option value = "62"> 블러링 </option>
                                <option value = "63"> 가우시안 스무딩 </option>
                                <option value = "64"> 샤프닝 </option>
                                <option value = "65"> 고주파 </option>
                                <option value = "66"> 저주파 </option>
                            </optgroup>
                                <optgroup label ="경계선 처리기능">
                                <option value = "71"> LoG </option>
                                <option value = "72"> Dog </option>
                            </optgroup>
                        </div>

   
     </select>
    <canvas id='inCanvas2' style='background-color: #e4c0c0'width="300" height="300"></canvas>
  <canvas id='outCanvas2' style='background-color:rgb(164, 248, 192)'width="300" height="300"></canvas>
</div> 

  


    </article>
   
        
    
        <footer><div class="bar3"><h3>Domado Tool</h3></div></footer>
            <br>
        </div>

        </form>
    </div>
    </body>
</aside>
</html>
